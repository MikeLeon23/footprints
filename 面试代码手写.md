# 面试代码手写题

## 手写Promise

手写简化Promise

```js
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  that.state = PENDING
  that.value = null
  that.resolvedCallback = []
  that.rejectedCallback = []

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = RESOLVED
      that.value = value
      that.resolvedCallback.map(cb => cb(that.value))
    }
  }

  function reject(value) {
    if (that.state === PENDING) {
      that.state = REJECTED
      that.value = value
      that.rejectedCallback.map(cb => cb(that.value))
    }
  }

  try {
    fn(resolve, reject)
  } catch(e) {
    reject(e)
  }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  const that = this
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
  onRejected = typeof onRejected === 'function' ? onRejected : r => {throw r}

  if (that.state === PENDING) {
    that.resolvedCallback.push(onFulfilled)
    that.rejectedCallback.push(onRejected)
  }

  if (that.state === RESOLVED) {
    onFulfilled(that.value)
  }

  if (that.state === REJECTED) {
    onRejected(that.value)
  }
}
```



## 手写call、apply、bind

```js
// call
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const args = [...arguments].slice(1)
  const result = context.fn(...args)
  delete context.fn
  return result
}
```

```js
// apply
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

```js
// bind
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```



## 封装jsonp

### 简单实现

需要事先写好url，而不是根据传递的请求参数对象自动拼接url

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}

// 调用
jsonp('http://xxx', 'callback', function(value) {
  console.log(value)
})
```

### 进阶实现

```js
// params是请求参数对象
function JSONP({url, params, callbackKey, callback}) {
  // 在参数里制定 callback 的名字
  params = params || {}
  params[callbackKey] = 'jsonpCallback'
    // 预留 callback
  window.jsonpCallback = callback
    // 拼接参数字符串
  const paramKeys = Object.keys(params)
  const paramString = paramKeys
    .map(key => `${key}=${params[key]}`)
    .join('&')
    // 插入 DOM 元素
  const script = document.createElement('script')
  script.setAttribute('src', `${url}?${paramString}`)
  document.body.appendChild(script)
}

// 调用
JSONP({  
  url: 'http://s.weibo.com/ajax/jsonp/suggestion',
  params: {
    key: 'test',
  },
  callbackKey: '_cb',
  callback(result) {
    console.log(result.data)
  }
})
```

**对于同时进行多个请求的优化：**

- 对所有的回调函数进行编码，并且在调用时告诉后端对应的独一无二的编号。
- 污染全局空间显然是个不明智的选择，这个问题解决起来倒是非常简单，扔到 JSONP.xxx下即可。

```js
function JSONP({url, params, callbackKey, callback}) {
  // 唯一 id，不存在则初始化
  JSONP.callbackId = JSONP.callbackId || 1
  params = params || {}
    // 传递的 callback 名，和下面预留的一致
  params[callbackKey] = `JSONP.callbacks[${JSONP.callbackId}]`
    // 不要污染 window
  JSONP.callbacks = JSONP.callbacks || []
    // 按照 id 放置 callback
  JSONP.callbacks[JSONP.callbackId] = callback
  const paramKeys = Object.keys(params)
  const paramString = paramKeys
    .map(key => `${key}=${params[key]}`)
    .join('&')
  const script = document.createElement('script')
  script.setAttribute('src', `${url}?${paramString}`)
  document.body.appendChild(script)
    // id 占用，自增
  JSONP.callbackId++
}

// 调用
JSONP({  
  url: 'http://s.weibo.com/ajax/jsonp/suggestion',
  params: {
    key: 'test',
  },
  callbackKey: '_cb',
  callback(result) {
    console.log(result.data)
  }
})
JSONP({  
  url: 'http://s.weibo.com/ajax/jsonp/suggestion',
  params: {
    key: 'excited',
  },
  callbackKey: '_cb',
  callback(result) {
    console.log(result.data)
  }
})
```



## requestAnimationFrame

使用requestAnimationFrame封装通用动画函数

```js
/**
 * 补间动画方法
 * @param { Number } start 开始数值
 * @param { Number } end   结束数值
 * @param { Number } time  补间时间
 * @param { Function } callback 每帧的回调函数
 **/
function animate(start, end, time, callback){
	var startTime = performance.now(); // 设置开始的时间戳
	var differ = end - start; // 拿到数值差值
	// 创建每帧之前要执行的动画
    function loop(now){
        var passTime = now - startTime; // 获取当前时间和开始的时间差
        var per = passTime / time; // 计算当前已过百分比
        if( per >= 1 ){  // 判断如果已经执行完毕
            per = 1; // 设置为最后的状态
        }
        var pass = differ * per; // 通过已过时间的百分比 * 开始结束数值差得出当前的数值
        callback(pass); // 调用回调函数,把数值传递进去,这里的回调函数应该是移动函数
        if(per < 1) requestAnimationFrame(loop) //下一帧调用每帧之前要执行的函数
    }
    requestAnimationFrame(loop) // 下一帧调用每帧之前要执行的函数
}
```

