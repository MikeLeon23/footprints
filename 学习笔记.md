- class和id
一般都使用class定义样式，id一般用于js快速的区别和获取元素class，一般都用中横线分割，id一般都是用驼峰命名法。
- 必不可少的图片
必不可少的图片使用<img>嵌入到页面中，而不适用css样式表引入。
- em 相对长度单位
1. em相对参照物为父元素的font-size
2. em具有继承的特点
3. 当没有设置font-size时，浏览器会有一个默认的em设置：1em = 16px
- em的缺点：容易混乱
- rem的相对参照物为根元素html，由于参照物固定不变所以比较好计算
- 当没有设置font-size时，浏览器会有一个默认的rem设置：1rem = 16px，这点与em时一致的。唯一一个问题是IE6-8不支持
- chrome浏览器最小字号有一个下限，这个下限会强制改变小于该值的文字大小。中文版chrome是12px，英文版chrome是10px或更低。所以想要精确控制height时，不要用rem，直接设置px.
- 媒体查询的级别很高，并不是HTML的一个子元素，级别不在HTML之下。所以在媒体查询中设置rem，得到的结果不是相对于HTML的font-size的，而是相对于浏览器的默认的font-size的，一般是16px。
- JS中访问对象的属性，不需要加括号，比如var x=myarray.length; 访问对象的方法，需要加括号，比如var request=mystr.toUpperCase();
- 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐(即默认vertical-align: baseline)。这样会造成一个问题，就是图片底侧会有一个空白缝隙。
  - 解决方法一：vertical-align:top | bottom | middle
    解决方法二： 将行内元素或行内块元素转换为块级元素
  - PS：vertical-align不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片/表单与文字的对齐。

#### 块级元素居中的四种方法

```css
/*方法一：严格计算margin（需要宽高已知）*/
.box1 .inner {
    width: 80px;
    height: 80px;
    margin: 0 auto;
}
```

```css
/* 方法二：定位解决（需要宽高已知）*/
.box2 .inner {
    width: 80px;
    height: 80px;
    position: absolute;
    left: 50%;
    top: 50%;
    margin-top: -40px;
    margin-left: -40px;
}
```

```css
/* 方法三：定位（需要宽高已知）*/
.box3 .inner {
    width: 80px;
    height: 80px;
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;
    margin: auto;
}
```

```css
/* 方法四：translate变换（盒子宽高不知道，是由内容撑起来）*/
.box4 .inner {
    width: 80px;
    position: absolute;
    left: 50%;
    top: 50%;
    /* margin的百分数，是以盒子宽度为参照 */
    /* translate中的50%是自身的50% */
    transform: translateY(-50%) translateX(-50%);
}
```

```css
/* flex布局 */
.box {
    display: flex;
}
.box5 .inner {
    margin: auto;
}
```

#### 两对鼠标事件的比较

- mouseenter/mouseleave，进入元素的子元素的时候不会触发，整体只触发一次
- mouseouver/mouseout，进入元素的子元素的时候也会触发，在子元素内部来回进入时也会触发

#### querySelectorAll和getElementByClass / getElementByTagName、ele.children区别

- querySelectorAll 获取的是静态类型列表，不会更新节点，但是可以使用forEach方法，比较便利（但不能使用数组的其他所有方法）
- getElementByClass / getElementByTagName和ele.children，获得的是HTMLCollection对象，是动态类型列表，会实时更新列表内容，但是不能使用数组forEach方法。

#### unload和beforeunload事件

unload和beforeunload是在窗口卸载的时候会触发，可以在用户刷新或者关闭窗口的时候处理一些逻辑，如果在两个事件监听中添加 alert、confirm、prompt会忽略，所以我们想提示用户或者想调试一下这种方法是不可行的。不过可以通过写入localStorage进行调试

```js
window.addEventListener('unload', ()=>{
   localStorage.setItem("unload","addEventListener.unload");
});
window.addEventListener('beforeunload', ()=>{
    localStorage.setItem("beforeunload","addEventListener.beforeunload");
});
```

#### fixed定位的特点

fixed定位的元素的宽高如果设定为百分比，它是由视口的大小决定的，不会被其他任何元素影响。如果设置成100%，内容超出时不会产生滚动条。fixed定位默认overflow: visible，如果子元素移动到视口中也是可见的。而absolute定位，内容超出视口，会产生滚动条，并且元素会随着页面滚动。

#### 将body的高度100%问题

如果想要在网页元素总体高度小于视口的情况下，让body的高度为网页视口的100%，只设置样式body{height: 100%;}是不行的，只设置html{height: 100%;}也不行，需要将他俩同时设置才行

```css
html, body {
    height: 100%;
}
```

#### 使链接点击后不做任何事的方法

```html
<a href="javascript:;">你好</a>

// 另一种方法
<a href="javascript:void(0)">你好</a>
```

#### 怎样精确区分这些名词：库、插件、组件、控件、扩展？

来源：知乎回答

库、框架、插件、加载项、扩展和控件都是组件。

- 组件(Component)是是一个含义很大的概念，一般是指软件系统的一部分，承担了特定的职责，可以独立于整个系统进行开发和测试，一个良好设计的组件应该可以在不同的软件系统中被使用(可复用)。例如V8引擎是Chrome浏览器的一部分，负责运行javascript代码，这里V8引擎就可以视为一个组件。V8引擎同时也是Node.js的javascript解释器，这体现了组件的可复用性。

- 库(Library)是一系列预先定义好的数据结构和函数(对于面向对象语言来说，是类)的集合，程序员通过使用这些数据结构和函数实现功能。例如Moment.js是一个javascript库，提供了处理时间的一些函数。

- 框架(Framework)也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，但程序真正的功能还需要由开发者实现。框架和库的最大区别在于“控制反转”，当你使用一个库，你会调用库中的代码，而当你使用一个框架，框架会调用你的代码。框架和库是一个有交叉的概念，很多框架都是以库的形式发布的，例如Java的Spring MVC框架，其发布的jar包本身就是一个库。而一个库如果也能通过依赖反转的方式进行扩展，那也可以视为一个框架，例如Python的markdown解析库Python Markdown，可以添加自定义的解析扩展，那么可以被视为一个markdonw解析框架。下面这张图出自这篇博客[Library vs. Framework?](https://link.zhihu.com/?target=http%3A//www.programcreek.com/2011/09/what-is-the-difference-between-a-java-library-and-a-framework/)，从调用方式的角度比较了库和框架。

![img](https://pic3.zhimg.com/50/f6537f5d3b92c6e0c79f691873a3ea5c_hd.jpg)



- 插件(Plugin)和扩展(extension)是两个很相似的概念，我没有办法在软件系统的角度给出这二者的区别。插件(或扩展)是对已有应用程序或者库的功能补充，一个软件的插件(或扩展)是实现了该软件预定义接口的组件，用来向已有的软件添加功能。插件在目标软件发布时可以不预先包含，而是在运行时被使用者注册，然后再被目标软件调用。另一个很接近的概念是加载项(Add-on)，可以认为加载项是插件(或扩展)的子集，是仅针对应用程序来说的功能补充。一个插件的例子是Flash的浏览器插件，为浏览器实现了运行Flash程序的功能。

- 控件(Control)是gui编程的一个概念，一般来说一个最终用户可以看到的、可交互的组件，被称为一个控件。例如.NET编程中的System.Windows.Controls.Button是一个控件。

#### 怎样写一个库？

```js
;	// 前面写上一个分号保护后面的立即执行函数()不被连接导致报错
(function(w){	// 使用立即执行函数包裹，避免作用域相互影响，否则出现和库重名的函数，会出错
    function Swiper(select, params){	// 声明构造函数
        
        // 接收配置参数。
        this.params = Object.assign({
            loop: false,	// 预定义参数的默认值，如果没有传入相关值则使用默认值
            autoplay: false,
            pagination: false
        }, params);
    };
    
    // 给构造函数的原型添加方法，这些方法是所有构造函数生成的实例所共用的
    Swiper.prototype = {	// 这里直接重写函数原型，会导致constructor指针丢失，不推荐
        
    };
    
    // 给构造函数原型添加方法的推荐方式：
    Swiper.prototype.init = function(){
        
    };
    
	w.Swiper = Swiper;	// 将构造函数暴露给window对象，否则外面无法调用它
})(window);		// 将window传给立即执行函数，以便于内部将构造函数暴露给window。
```

